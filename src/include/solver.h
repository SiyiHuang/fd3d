#ifndef GUARD_solver_h
#define GUARD_solver_h

#include "gridinfo.h"
#include "output.h"

#include "petsc.h"

typedef PetscErrorCode (*IterativeSolver)(const Mat A, Vec x, const Vec b, const Vec right_precond, const Mat HE, GridInfo gi);

PetscErrorCode bicgSymmetric_kernel(const Mat A, Vec x, const Vec b, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);

PetscErrorCode bicgSymmetric(const Mat A, Vec x, const Vec b, const Vec right_precond, const Mat HE, GridInfo gi);

PetscErrorCode cgs_kernel(const Mat A, Vec x, const Vec b, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);

PetscErrorCode cgs(const Mat A, Vec x, const Vec b, const Vec right_precond, const Mat HE, GridInfo gi);

PetscErrorCode bicg_kernel(const Mat A, Vec x, const Vec b, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);

/**
 * Use Hermitian transpose rather than transpose.
 */
PetscErrorCode bicg_kernel_H(const Mat A, Vec x, const Vec b, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);

PetscErrorCode bicg(const Mat A, Vec x, const Vec b, const Vec right_precond, const Mat HE, GridInfo gi);

/**
 * QMR algorithm without look-ahead.  
 * This is the implementation of Algorithm 3.1 in Freund and Szeto, A Quasi-minimal residual 
 * squared algorithm for non-Hermitian linear systems, Proc. 1992 Copper Mountain Conf. on 
 * Iterative Methods.
 */
PetscErrorCode qmr_kernel(const Mat A, Vec x, const Vec b, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);


/**
 * QMR based on coupled recurrences.
 * This is the implementation of Algorithm 7.1 in Freund and Nachtigal, An implementation of the
 * QMR method based on coupled two-term recurrences, SIAM J. Sci. Comput., Vol. 15, No. 2, 1994.
 */
PetscErrorCode qmr2_kernel(const Mat A, Vec x, const Vec b, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);


/**
 * QMR algorithm using A^H instead of A^T.
 * This modifies qmr_kernel() so that the left Krylov subspace is generated by multiplying A^H 
 * instead of A^T.  The hope is to have the matrix V, whose columns are the basis vectors of the 
 * right Krylov subspace, is biorthogonal to the matrix W, whose columns are the basis vectors of 
 * the left Krylov subspace, so that W^H V is diagoal.  (qmr_kernel() creates V and W such that 
 * W^T V is diagonal.)
 * This makes V = W for Hermitian A.
 */
PetscErrorCode qmr3_kernel(const Mat A, Vec x, const Vec b, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);


/**
 * QMR algorithm using A^H instead of A^T.
 * This modifies qmr2_kernel() so that the left Krylov subspace is generated by multiplying A^H 
 * instead of A^T.  The hope is to have the matrix V, whose columns are the basis vectors of the 
 * right Krylov subspace, is biorthogonal to the matrix W, whose columns are the basis vectors of 
 * the left Krylov subspace, so that W^H V is diagoal.  (qmr_kernel() creates V and W such that 
 * W^T V is diagonal.)
 * This makes V = W for Hermitian A.  Since QMR ensures 
 */
PetscErrorCode qmr4_kernel(const Mat A, Vec x, const Vec b, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);


PetscErrorCode qmr(const Mat A, Vec x, const Vec b, const Vec right_precond, const Mat HE, GridInfo gi);

PetscErrorCode testOrthogonal(GridInfo gi);

PetscErrorCode operateA(const Mat CH, const Mat CE, const Vec mu, const Vec eps, const PetscReal omega, const Vec x, Vec y);

PetscErrorCode operateAtr(const Mat CH, const Mat CE, const Vec mu, const Vec eps, const PetscReal omega, const Vec x, Vec y);

/**
 * multAandAdagger
 * ---------------
 * [y1; y2] = [0 A; Adag 0] * [x1; x2].
 */
PetscErrorCode multAandAdag(const Mat A, const Mat Adag, const Vec x1, const Vec x2, Vec y1, Vec y2);

/**
 * multAandAdaggerTranspose
 * ---------------
 * [y1; y2] = [0 A; Adag 0]^T * [x1; x2] = [0 Adag^T; A^T, 0] * [x1; x2]
 */
PetscErrorCode multAandAdagTranspose(const Mat A, const Mat Adag, const Vec x1, const Vec x2, Vec y1, Vec y2);

PetscErrorCode vecDot(const Vec x1, const Vec x2, const Vec y1, const Vec y2, PetscScalar *val);

PetscErrorCode vecTDot(const Vec x1, const Vec x2, const Vec y1, const Vec y2, PetscScalar *val);

PetscErrorCode vec2Norm(const Vec x1, const Vec x2, PetscReal *val);

PetscErrorCode vecNormalize(Vec x1, Vec x2, PetscReal *val);

PetscErrorCode cgAandAdag_kernel(const Mat A, const Mat Adag, Vec x1, Vec x2, const Vec b1, const Vec b2, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);

PetscErrorCode cgAandAdag(const Mat A, const Mat Adag, Vec x1, Vec x2, const Vec b1, const Vec b2, const Vec right_precond, const Mat HE, GridInfo gi);

PetscErrorCode bicgAandAdag_kernel(const Mat A, const Mat Adag, Vec x1, Vec x2, const Vec b1, const Vec b2, const Vec right_precond, const PetscInt max_iter, const PetscReal tol, const Mat HE, GridInfo gi, MonitorIteration monitor);

PetscErrorCode bicgAandAdag(const Mat A, const Mat Adag, Vec x1, Vec x2, const Vec b1, const Vec b2, const Vec right_precond, const Mat HE, GridInfo gi);

#endif
